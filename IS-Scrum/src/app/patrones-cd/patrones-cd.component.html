<app-navbar></app-navbar>
<div class="container-fluid">
  <div class="row">
    <div class="col-lg-10 container-prueba">
      <a class="titulo-desarrollador">Creacional</a>
      <p class="texto-referencias">
        Son los que facilitan la tarea de creación de nuevos objetos, de tal forma que el proceso de creación pueda ser desacoplado de la implementación del resto del sistema. Los patrones creacionales están basados en dos conceptos:</p>
      <p class="texto-referencias">
        1.- Encapsular el conocimiento acerca de los tipos concretos que nuestro sistema utiliza. Estos patrones normalmente trabajarán con interfaces, por lo que la implementación concreta que utilicemos queda aislada.<br>2.- Ocultar cómo estas implementaciones concretas necesitan ser creadas y cómo se combinan entre sí.
      </p>
      <p class="texto-referencias">
        Los patrones creacionales más conocidos son:
      </p>
      <p class="texto-referencias">
        <li>
          <strong>Abstract Factory.</strong> Nos provee una interfaz que delega la creación de un conjunto de objetos relacionados sin necesidad de especificar en ningún momento cuáles son las implementaciones concretas.
        </li>
        <li>
          <strong>Factory Method.</strong> Expone un método de creación,  delegando en las subclases la implementación de este método.
        </li>
        <li>
          <strong>Builder.</strong> Separa la creación de un objeto complejo de su estructura, de tal forma que el mismo proceso de construcción nos puede servir para crear representaciones diferentes.
        </li>
        <li>
          <strong>Singleton.</strong> Limita a uno el número de instancias posibles de una clase en nuestro programa, y proporciona un acceso global al mismo.
        </li>
        <li>
          <strong>Prototype.</strong> Permite la creación de objetos basados en «plantillas». Un nuevo objeto se crea a partir de la clonación de otro objeto.
        </li>
      </p>
    </div>
    <div class="col-lg-2"></div>
  </div>
  <div class="row">
    <div class="col-lg-2"></div>
    <div class="col-lg-10 container-prueba">
      <a class="titulo-desarrollador">Estructural</a>
      <p class="texto-referencias">
        Son patrones que nos facilitan la modelización de nuestros software especificando la forma en la que unas clases se relacionan con otras. Estos son los patrones estructurales:
      </p>
      <p class="texto-referencias">
        <li>
          <strong>Adapter.</strong> Permite a dos clases con diferentes interfaces trabajar entre ellas, a través de un objeto intermedio con el que se comunican e interactúan.
        </li>
        <li>
          <strong>Bridge.</strong> Desacopla una abstracción de su implementación, para que las dos puedan evolucionar de forma independiente.
        </li>
        <li>
          <strong>Composite.</strong> Facilita la creación de estructuras de objetos en árbol, donde todos los elementos emplean una misma interfaz. Cada uno de ellos puede a su vez contener un listado de esos objetos, o ser el último de esa rama.
        </li>
        <li>
          <strong>Decorator.</strong> Permite añadir funcionalidad extra a un objeto (de forma dinámica o estática) sin modificar el comportamiento del resto de objetos del mismo tipo.
        </li>
        <li>
          <strong>Facade.</strong> Una facade (o fachada) es un objeto que crea una interfaz simplificada para tratar con otra parte del código más compleja, de tal forma que simplifica y aísla su uso. Un ejemplo podría ser crear una fachada para tratar con una clase de una librería externa.
        </li>
        <li>
          <strong>Flyweight.</strong> Una gran cantidad de objetos comparte un mismo objeto con propiedades comunes con el fin de ahorrar memoria.
        </li>
        <li>
          <strong>Proxy. </strong> Es una clase que funciona como interfaz hacia cualquier otra cosa: una conexión a Internet, un archivo en disco o cualquier otro recurso que sea costoso o imposible de duplicar.
        </li>
      </p>
    </div>
  </div>
  <div class="row">
    <div class="col-lg-10 container-prueba">
      <a class="titulo-desarrollador">Comportamiento</a>
      <p class="texto-referencias">
        En este último grupo se encuentran la mayoría de los patrones, y se usan para gestionar algoritmos, relaciones y responsabilidades entre objetos. Los patrones de comportamiento son:
      </p>
      <p class="texto-referencias">
        <li>
          <strong>Command.</strong> Son objetos que encapsulan una acción y los parámetros que necesitan para ejecutarse.
        </li>
        <li>
          <strong>Chain of responsibility.</strong> se evita acoplar al emisor y receptor de una petición dando la posibilidad a varios receptores de consumirlo. Cada receptor tiene la opción de consumir esa petición o pasárselo al siguiente dentro de la cadena.
        </li>
        <li>
          <strong>Interpreter.</strong> Define una representación para una gramática así como el mecanismo para evaluarla. El árbol de sintaxis del lenguaje se suele modelar mediante el patrón Composite.
        </li>
        <li>
          <strong>Iterator.</strong> Se utiliza para poder movernos por los elementos de un conjunto de forma secuencial sin necesidad de exponer su implementación específica.
        </li>
        <li>
          <strong>Mediator.</strong> Objeto que encapsula cómo otro conjunto de objetos interactúan y se comunican entre sí.
        </li>
        <li>
          <strong>Memento.</strong> Este patrón otorga la capacidad de restaurar un objeto a un estado anterior.
        </li>
        <li>
          <strong>Observer.</strong> Los objetos son capaces de suscribirse a una serie de eventos que otro objetivo va a emitir, y serán avisados cuando esto ocurra.
        </li>
        <li>
          <strong>State.</strong> Permite modificar la forma en que un objeto se comporta en tiempo de ejecución, basándose en su estado interno.
        </li>
        <li>
          <strong>Strategy.</strong> Permite la selección del algoritmo que ejecuta cierta acción en tiempo de ejecución.
        </li>
        <li>
          <strong>Template Method.</strong> Especifica el esqueleto de un algoritmo, permitiendo a las subclases definir cómo implementan el comportamiento real.
        </li>
        <li>
          <strong>Visitor.</strong> Permite separar el algoritmo de la estructura de datos que se utilizará para ejecutarlo. De esta forma se pueden añadir nuevas operaciones a estas estructuras sin necesidad de modificarlas.
        </li>
      </p>
    </div>
    <div class="col-lg-2"></div>
  </div>
</div>
